# java垃圾回收机制

从三个角度来理解gc

- jvm怎么确定哪些对象应该进行回收
- jvm会在什么时候进行垃圾回收的动作
- jvm到底是怎么清楚垃圾对象的



## 1. jvm怎么确定哪些对象应该进行回收

对象是否会被回收的两个经典算法：**引用计数法**，和**可达性分析算法**。

### 引用计数法

简单来说就是判断对象的引用次数。

给对象添加一个引用次数，每当对他进行引用时，计数器加1，当引用失效时，计数器减1，当某一个对象的计数器为0时，表示没人对他进行引用，可以被gc掉。

这种简单的算法在当前的jvm中并没有采用，原因是他并不能解决对象之间循环引用的问题。

### 可达性分析算法

就是从GC Root向下进行搜索，当一个对象到RC ROOT没有任何引用链时，则表明对象不可达，在java中，可以当成RC ROOT的节点：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性实体引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。

## 2.在确定了哪些对象可以被回收之后，jvm会在什么时候进行回收

1. 会在cpu空闲的时候自动进行回收
2. 在堆内存存储满了之后
3. 主动调用System.gc()后尝试进行回收

## 3. 如何回收

垃圾收集的算法：标记-清除算法,复制算法,标记-整理算法,分代收集算法.

### 标记-清楚算法

​		这是最基础的一种算法，分为两个步骤，第一个步骤就是标记，标记所有需要回收的对象，第二步把所有标记过的对象进行统一的回收。

​		这种算法效率不高，另一个就是清除之后会产生大量不连续的内容碎片，容易在程序以后的运行过程中需要分配大对象时，因找不到足够的连续内容而造成内存空间浪费。

<img src="/Users/nate/Library/Application Support/typora-user-images/image-20191117171305500.png" alt="image-20191117171305500" style="zoom:33%;" />

### 复制算法

​		复制将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

​		这样每次都是对其中一块内存进行收回，解决了内存碎片的情况，但是这种算法的代价就是将内存的使用缩小为原来的一半。另外一个就是对象存活率较高时就要执行较多的复制操作，效率将会变低。

<img src="/Users/nate/Library/Application Support/typora-user-images/image-20191117171657064.png" alt="image-20191117171657064" style="zoom:33%;" />

### 标记整理算法

标记整理算法和标记清楚算法很像，区别在于标记整理算法在对对象进行处理清除之后，对剩余的存活对象进行整理，重新整理，因此其不会产生内存碎片。

<img src="/Users/nate/Library/Application Support/typora-user-images/image-20191117171859552.png" alt="image-20191117171859552" style="zoom:33%;" />

### 分代收集算法

分代收集算法是当前jvm使用最多的一个方式。他会针对新生代，老年代，永久代使用上述的三种算法。

#### 1. 新生代

​		对新生代收集的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先会放到新生代中。

​		新生代会按照8:1:1的比例分为一个eden区和2个survivor区，大部分对象在eden区生成。在进行垃圾回收时，

	1. 先将eden区中存活的对象复制到survivor0区中，
 	2. 然后清空eden区，
 	3. 当这个survivor区满了之后，会将eden区和survivor0区中存活的对象复制到survivor1区中
 	4. 然后情况eden和survivor0区，
 	5. 此时survivor0区是空的，然后交换survivor0和survivor1的角色，就是下次回收时，会扫描eden区和survivor1区。
 	6. 重复此过程。

这里当survivor1区也不足以存放eden和survivor0区复制过来的对象时，则将对象直接放到老年代。如果老年代也满了，则触发一次full gc，也就是新生代和老年代一起回收。

注意：新生代发生的gc叫minorGC，minorGC发生的频率较高，不一定要等eden区满了才触发。

#### 2. 老年代

​		老年代存放的都是一些存活时间较长的对象，在新生代经过n次(默认15次)垃圾回收依然存活的对象。此外老年代的内容比新生代的内容也要大很多，大概比例为1:2。如果老年代也满了，则触发一次full gc(majorGC)，也就是新生代和老年代一起回收。

#### 3. 永久代

​		永久代主要存放静态文件，入java类、方法等

#### 总结

1、在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。
2、老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须用标记-清除或者标记-整理。





*注意:*
*在jdk8的时候java废弃了永久代，但是并不意味着我们以上的结论失效，因为java提供了与永久代类似的叫做“元空间”的技术。*
*废弃永久代的原因：由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryErroy。元空间的本质和永久代类似。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。也就是不局限与jvm可以使用系统的内存。理论上取决于32位/64位系统可虚拟的内存大小。*