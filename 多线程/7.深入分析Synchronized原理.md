# 深入分析Synchronized原理

## 1. 基本使用

**Synchronized的作用主要有三个**：

1. **原子性**：确保线程互斥的访问同步代码；

2. **可见性**：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 **“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”** 来保证的；

3. **有序性**：有效解决重排序问题，即 **“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”**；

## 2. 同步原理

### 2.1  同步代码块

```java
public class SynchronizedDemo {
    public void method() {
        synchronized (this) {
            System.out.println("Method 1 start");
        }
    }
}
```

上面的代码反编译后：

![image-20191022203659004](/Users/nate/Library/Application Support/typora-user-images/image-20191022203659004.png)

1. **monitorenter**：**插入在同步代码块的开始位置**，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；，过程如下：

> 1. **如果monitor的进入数为0**，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；
>
> 2. **如果线程已经占有该monitor**，只是重新进入，则进入monitor的进入数加1；
>
> 3. **如果其他线程已经占用了monitor**，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；

2. **monitorexit**：**插入在方法结束处和异常处**，JVM保证每个MonitorEnter必须有对应的MonitorExit。**指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者**。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。

> **monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁**；

**总结：**Synchronized的**语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象**，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，**否则会抛出java.lang.IllegalMonitorStateException的异常的原因**。

### 2.2 同步方法

```java
public class SynchronizedMethod {
    public synchronized void method() {
        System.out.println("Hello World!");
    }
}
```

查看反编译结果后：

![image-20191022204052504](/Users/nate/Library/Application Support/typora-user-images/image-20191022204052504.png)

由反编译结果可以看出。当方法调用时，**调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置**，如果设置了，**执行线程将先获取monitor**，获取成功之后才能执行方法体，**方法执行完后再释放monitor**。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。

## 3. 同步概念

​	Monitor是由ObjectMonitor实现的，当多个线程访问同一段代码时：

1. 首先会进入 _EntryList 集合，**当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1**；

2. 若线程调用 wait() 方法，**将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒**；

3. 若当前线程执行完毕，**也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)**；



监视器Monitor有两种同步方式：**互斥与协作**。

**什么时候需要协作？** 比如：

一个线程向缓冲区写数据，另一个线程从缓冲区读数据，如果读线程发现缓冲区为空就会等待，当写线程向缓冲区写入数据，就会唤醒读线程，**这里读线程和写线程就是一个合作关系**。JVM通过Object类的wait方法来使自己等待，在调用wait方法后，该线程会释放它持有的监视器，直到其他线程通知它才有执行的机会。一个线程调用notify方法通知在等待的线程，这个等待的线程并不会马上执行，而是要通知线程释放监视器后，它重新获取监视器才有执行的机会。如果刚好唤醒的这个线程需要的监视器被其他线程抢占，那么这个线程会继续等待。Object类中的notifyAll方法可以解决这个问题，它可以唤醒所有等待的线程，总有一个线程执行。

![image-20191022205204558](/Users/nate/Library/Application Support/typora-user-images/image-20191022205204558.png)

如上图所示，一个线程通过1号门进入Entry Set(入口区)，如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。线程在持有监视器的过程中，有两个选择，**一个是正常执行监视器区域的代码**，释放监视器，通过5号门退出监视器；**还有可能等待某个条件的出现**，于是它会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。

注意：

> 当一个线程释放监视器时，**在入口区和等待区的等待线程都会去竞争监视器**，如果入口区的线程赢了，会从2号门进入；如果等待区的线程赢了会从4号门进入。**只有通过3号门才能进入等待区，在等待区中的线程只有通过4号门才能退出等待区**，也就是说一个线程只有在持有监视器时才能执行wait操作，处于等待的线程只有再次获得监视器才能退出等待状态。



## 4 锁的优化

锁主要存在四种状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁只能从低到高升级，不能出现锁降级。

### 4.1 自旋锁

**线程的阻塞和唤醒需要CPU从用户态转为核心态，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的**，所以引入了自旋锁。

> 所谓自旋锁，就是指当一个线程尝试获取某个锁时，**如果该锁已被其他线程占用，就一直循环检测锁是否被释放**，而不是进入线程挂起或睡眠状态.

**如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源**，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。

假如自旋锁的系数调整到10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。**于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明**。

### 4.2 适应性自旋锁

**所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**。

**线程如果自旋成功了，那么下次自旋的次数会更加多**，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，**如果对于某个锁，很少有自旋能够成功**，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

### 4.3 锁消除

**在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除**。

### 4.4 锁粗化

**锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁**

### 4.5 偏向锁

待补充，目前看不下去