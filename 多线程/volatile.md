# 1. Volatile的特性

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）

- 禁止进行指令重排序。（实现有序性）

- volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性。



# 2. 实现原理

## 2.1 可见性实现

- volatile 变量的内存可见性是基于内存屏障（Memory Barrier）实现， 有待商榷。

  - 内存屏障，又称内存栅栏，是一个 CPU 指令。
  - 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。

- volatile在反编译后会产生一个lock前缀的指令

  - lock指令会做两件事情：
    - 将当前处理器缓存行的数据写回到系统内存。
    - 写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效。

- 为了保证各个处理器的缓存是一致的，实现了缓存一致性协议（MESI），每个处理器通过嗅探(一种协议)在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里

  - 所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值

  

  ### 2.1.1 缓存一致性

  - 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。
  - 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个 CPU 缓存可以读写内存）。
  - CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。
  - 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。
    - 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。

## 2.2 有序性实现

### 2.2.1 volatile 的 happens-before 关系

happens-before 规则中有一条是 **volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读**

### 2.2.2 volatile 禁止重排序

主要是通过内存屏障来组织编译器和处理器对指令进行重排。

- JMM 会针对编译器制定 volatile 重排序规则表
  - 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
  - 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
  - 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
  - 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。

也就是说volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。

